<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xs:schema elementFormDefault="qualified"
			xmlns:xs="http://www.w3.org/2001/XMLSchema"
			xmlns="http://www.springactionscript.org/schema/objects"
			targetNamespace="http://www.springactionscript.org/schema/objects">

	<xs:annotation>
		<xs:documentation><![CDATA[
Spring ActionScript Framework 1.0 Schema
Schema Authors: Ryan Gardner, Erik Westra, Christophe Herreman

This defines a simple and consistent way of creating a namespace
of ActionScript objects, managed by a Spring ActionScript IoC Container, read by
XmlObjectDefinitionParser.

Every attempt has been made to make this scheme comprehensive and correct.

Configuring your XML context-configuration like this:

	<?xml version="1.0" encoding="UTF-8" standalone="no"?>

	<objects xmlns="http://www.springactionscript.org/schema/objects"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://www.springactionscript.org/schema/objects
			http://www.springactionscript.org/schema/objects/spring-actionscript-objects-1.0.xsd">

		<!-- object and template definitions -->

	</objects>

Will enable most schema-aware tools to automatically retrieve the schema and provide
on-the-fly validation and code-completion as you create your context definition.

The main goal of this schema is to provide easy assistance in creating the file, and
basic validation of the syntax. Please feel free to provide updates to the Prana team
if you see any areas to improve.
			]]>
		</xs:documentation>
	</xs:annotation>

	<xs:group name="arrayElements">
		<xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="value" type="valueType" />
				<xs:element name="object" type="objectType"/>
				<xs:element name="param" type="templateParamType" />
				<xs:element name="array" type="arrayType" />
				<xs:element name="array-collection" type="arrayCollectionType" />
				<xs:element name="dictionary" type="dictionaryType" />
				<xs:element name="ref" type="xs:string" />
				<xs:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
			</xs:choice>
		</xs:sequence>
	</xs:group>

	<xs:group name="objectElements">
		<xs:choice>
			<xs:element name="object" type="objectType" />
			<xs:element name="param" type="templateParamType" />
			<xs:element name="array" type="arrayType" />
			<xs:element name="array-collection" type="arrayCollectionType" />
			<xs:element name="dictionary" type="dictionaryType" />
			<xs:element name="value" type="valueType" />
			<xs:element name="ref" type="xs:string" />
		</xs:choice>
	</xs:group>

	<xs:element name="objects" >
		<xs:complexType mixed="true">
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="import" type="importType" />
				<xs:element name="property" type="externalPropertyType" />
				<xs:element name="template" type="templateType" />
				<xs:element name="object" type="objectType" />
				<xs:element name="interface" type="interfaceType" />
				<xs:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>

	<xs:complexType name="importType">
		<xs:annotation>
			<xs:documentation xml:lang="en">Imports an external configuration file, this way its possible to split up a configuration into multiple files to keep a better overview or to keep different version of the configuration across different servers.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="file" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="en">A valid URI for the specified file. For a flex project this can be a relative URI, when used in an AIR application make sure to add a fully qualified local URI such as file:///subconfig.xml</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="externalPropertyType" mixed="true">
		<xs:annotation>
			<xs:documentation><![CDATA[Can be used to load external properties from a file. This is
similar to how Ant loads external properties.

<property file="strings.properties" />

the property file looks like:

s1=First string
s2=Second string

Note: the path to the property file is relative to the path of
the application context xml file.

Note: on some servers, the "properties" extension might be
blocked. You can either allow the extension in the server
configuration or add an extra "txt" (or other) prefix that is
allowed to be served:

<property file="strings.properties.txt" />

The properties loader will prevent caching of the properties by default, to turn this behavior off
set the prevent-cache attribute to false:

<property file="strings.properties.txt" prevent-cache="false"/>

By default the properties loader will throw an error if a properties file could not be loaded,
to ignore the error and resume loading set the required attribute to false:

<property file="strings.properties.txt" required="false"/>

it is also possible to directly define properties using this element. In this case
omit the file attribute and add the name and value as attributes, like this:

<property name="s1" value="First string"/>
<property name="s2" value="Second string"/>

The file attribute will take precedence over the name and value attributes.

]]>
			</xs:documentation>
		</xs:annotation>
		<xs:attribute type="xs:string" name="file">
			<xs:annotation>
				<xs:documentation xml:lang="en">A valid URI for the specified properties file. For a flex project this can be a relative URI, when used in an AIR application make sure to add a fully qualified local URI such as file:///subconfig.xml</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute type="xs:boolean" name="prevent-cache" use="optional" default="true">
			<xs:annotation>
				<xs:documentation xml:lang="en">If true the properties loader will make sure no cached copy of the file will be loaded</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute type="xs:boolean" name="required" use="optional" default="true">
			<xs:annotation>
				<xs:documentation xml:lang="en">If true the properties loader will throw an error when the file could not be loaded</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute type="xs:string" name="name">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of the property</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute type="xs:string" name="value">
			<xs:annotation>
				<xs:documentation xml:lang="en">The value of the property</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="templateType">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[A template is used to assist in creation of other objects. It can define
a number of properties that will be injected by the same values and
instances for every object based on this template.
To use a template, you can specify variables in braces (placeholders). Here is an example:

<template id="remoteObject">
	<object class="mx.rpc.remoting.mxml.RemoteObject">
		<property name="destination" value="GenericDestination"/>
		<property name="endpoint" ref="remoteGateway"/>
		<property name="source" value="ApplicationDomain.Services.${serviceClass}"/>
	</object>
</template>

and used like:

<object id="serviceLocator" class="org.springextensions.actionscript.cairngorm.CairngormServiceLocator"
		factory-method="getInstance">
	<property name="assetService" template="remoteObject">
		<param name="serviceClass" value="AssetService"/>
	</property>
	<property name="packageService" template="remoteObject">
		<param name="serviceClass" value="PackageService"/>
	</property>
	<property name="userService" template="remoteObject">
		<param name="serviceClass" value="UserService"/>
	</property>
</object>]]>
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation xml:lang="en">The base object for this template, this definition will be used for every object that is based on this template.</xs:documentation>
			</xs:annotation>
			<xs:element type="objectType" name="object"/>
		</xs:sequence>
		<xs:attribute type="xs:string" name="id" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A unique identifier for the specified template.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="constructor-argType" mixed="true">
		<xs:annotation>
			<xs:documentation>Constructor arguments. You can pass in a comma-delimited set of values, or a more complex value.</xs:documentation>
		</xs:annotation>
		<xs:group ref="objectElements" minOccurs="0" />
		<xs:attribute name="value" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A literal value for this particular argument. This can be a comma-delimited set of values</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ref" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A reference to an object defined in the container.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="template" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of a template which should be used to instantiate this specific argument. When defined as an attribute no parameters can be passed to the template, so no placeholder substitution will occur. Use a child template elementinstead if parameters are needed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="xs:string" use="optional">
		    <xs:annotation>
			<xs:documentation xml:lang="en">
			    Defines an optional type for the constructor argument, the value of the value attribute will be cast to this type at runtime.
			</xs:documentation>
		    </xs:annotation>
		</xs:attribute> 	
	</xs:complexType>

	<xs:complexType name="propertyType" mixed="true">
		<xs:annotation>
			<xs:documentation xml:lang="en">Defines the value of a property on an object.</xs:documentation>
		</xs:annotation>
		<xs:group ref="objectElements" minOccurs="0" />
		<xs:attribute name="name" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of the specified property.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="value" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A literal value for the property.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="type" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Defines an optional type for the property, the value of the value attribute will be cast to this type at runtime.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ref" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A reference to another object defined in the container.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="template" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of a template which should be used to instantiate this specific property. When defined as an attribute no parameters can be passed to the template, so no placeholder substitution will occur. Use a child template element instead if parameters are needed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="methodInvocationType">
		<xs:annotation>
			<xs:documentation xml:lang="en">Defines a method and optional method arguments. After instantiation of the object the specified method will be invoked with the specified arguments. No compile checks are possible for this definition, so if the method does not exist on the object this will result in a runtime error.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation xml:lang="en">Any number of arguments that should be passed to the specified method. Make sure to define the arguments in the same order as the method's signature.</xs:documentation>
			</xs:annotation>
			<xs:element name="arg" type="argType" minOccurs="0" maxOccurs="unbounded" />
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of the method.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="argType" mixed="true">
		<xs:annotation>
			<xs:documentation xml:lang="en">Defines a method argument.</xs:documentation>
		</xs:annotation>
		<xs:group ref="objectElements" minOccurs="0" />
		<xs:attribute name="value" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>A literal value for the argument.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ref" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>A reference to another object defined in the container.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="template" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of a template which should be used as the value of the specified argument. When defined as an attribute no parameters can be passed to the template, so no placeholder substitution will occur. Use a child template element instead if parameters are needed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="dictionaryType">
		<xs:annotation>
			<xs:documentation><![CDATA[A dictionary contains a list properties specified like this:

<property name="level">
	<dictionary>
		<entry>
			<key>a key</key>
			<value>a</value>
		</entry>
		<entry>
			<key>another key</key>
			<value>1</value>
		</entry>
		<entry>
			<key>true</key>
			<value>
				<array>
					<value>b</value>
					<value>c</value>
				</array>
			</value>
		</entry>
	</dictionary>
</property>]]>
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation xml:lang="en">Any number of entries that should be added to the dictionary instance.</xs:documentation>
			</xs:annotation>
			<xs:element type="entryType" name="entry" maxOccurs="unbounded" minOccurs="0" />
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="entryType" mixed="true">
		<xs:annotation>
			<xs:documentation xml:lang="en">Defines an entry that will be added to a dictionary instance.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="key" minOccurs="0" type="keyType"/>
			<xs:element name="value" minOccurs="0" type="valueType"/>
		</xs:sequence>
		<xs:attribute type="xs:string" name="key" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A literal key name for the specified entry.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute type="xs:string" name="value" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A literal value for the specified entry.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="keyType">
		<xs:annotation>
			<xs:documentation xml:lang="en">Defines a key that will be used for a dictionary entry.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:annotation>
				<xs:documentation xml:lang="en">A key can be any of the following types: object, array, array-collection, dictionary or ref.</xs:documentation>
			</xs:annotation>
			<xs:element name="object" type="objectType"/>
			<xs:element name="array" type="arrayType" />
			<xs:element name="array-collection" type="arrayCollectionType" />
			<xs:element name="dictionary" type="dictionaryType" />
			<xs:element name="ref" type="xs:string" />
		</xs:choice>
		<xs:attribute name="type" type="xs:string" use="optional" />
	</xs:complexType>

	<xs:complexType name="valueType" mixed="true">
		<xs:annotation>
			<xs:documentation xml:lang="en">Defines a value that will be used for a dictionary entry.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:annotation>
				<xs:documentation xml:lang="en">A value can be any of the following types.</xs:documentation>
			</xs:annotation>
			<xs:element name="object" type="objectType"/>
			<xs:element name="array" type="arrayType" />
			<xs:element name="array-collection" type="arrayCollectionType" />
			<xs:element name="dictionary" type="dictionaryType" />
			<xs:element name="ref" type="xs:string" />
		</xs:choice>
		<xs:attribute name="type" type="xs:string" use="optional" />
	</xs:complexType>

	<xs:complexType name="arrayType">
		<xs:annotation>
			<xs:documentation xml:lang="en">The array contains a list contains a list of the following possible values, these types can be mixed.</xs:documentation>
		</xs:annotation>
		<xs:group ref="arrayElements"/>
	</xs:complexType>

	<xs:complexType name="arrayCollectionType">
		<xs:annotation>
			<xs:documentation xml:lang="en">The array-collection contains a list of the following possible values, these types can be mixed</xs:documentation>
		</xs:annotation>
		<xs:group ref="arrayElements"/>
	</xs:complexType>
	
	<xs:complexType name="interfaceType" mixed="true">
		<xs:annotation>
			<xs:documentation xml:lang="en">The Interface type defines properties and methods for objects that implement the specified interface.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
		<xs:annotation>
			<xs:documentation xml:lang="en">The following elements can describe the object's properties and method invocations.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="property" type="propertyType" />
			<xs:element name="method-invocation" type="methodInvocationType" />
		</xs:choice>
		</xs:sequence>
		<xs:attribute type="xs:string" name="class" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The fully qualified classname for the specified interface. This class needs to be known at compile-time otherwise a runtime error will occur.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="init-method" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of a generic initialization method which will be called directly after instantiation and property injection.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="objectType" mixed="true">
		<xs:annotation>
			<xs:documentation xml:lang="en">The Object type defines the basic Object that is configured by the IoC container.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
		<xs:annotation>
			<xs:documentation xml:lang="en">The following elements can describe the object's constructor, properties and method invocations, and if the object is constructed based on a template then param elements can be defined which will be used by the template for placeholder substitution.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="property" type="propertyType" />
			<xs:element name="constructor-arg" type="constructor-argType" />
			<xs:element name="param" type="templateParamType" />
			<xs:element name="method-invocation" type="methodInvocationType" />
		</xs:choice>
		</xs:sequence>
		<xs:attribute type="xs:string" name="class" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The fully qualified classname for the specified object. This class needs to be known at compile-time otherwise a runtime error will occur.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute type="xs:string" name="id" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">A unique id. This id can be used to retrieve an object by calling the getObject method on the applicationcontext.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute type="xs:string" name="factory-method" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Optional method that will be called instead of the constructor.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="scope" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">When an object is a singleton, only one shared instance of the object will be managed, and all requests for objects with an id or ids matching that object definition will result in that one specific bean instance being returned by the Spring container. The non-singleton, prototype scope of object deployment results in the creation of a new object instance every time a request for that specific object is made (that is, it is injected into another object or it is requested via a programmatic getObject() method call on the container). As a rule of thumb, you should use the prototype scope for all objects that are stateful, while the singleton scope should be used for stateless objects.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:annotation>
					<xs:documentation xml:lang="en">Scope can be either prototype or singleton.</xs:documentation>
				</xs:annotation>
				<xs:restriction base="xs:string">
					<xs:enumeration value="prototype" />
					<xs:enumeration value="singleton" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="lazy-init" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">By default objects marked as a singleton will be constructed immediately after the container has finished initializing. When lazy-init is set to true though, instantation will be deferred until the first time that the getObject method is called for the specified singleton.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="init-method" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The name of a generic initialization method which will be called directly after instantation and property injection.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="singleton" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">When set to true, this property determines that the getObject method will always return a reference to the same instance of the specified object. When set to false, the getObject method will always return a new instance.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="template" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The id of a template defined in the current container.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="abstract" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">When set to true this property determines that the specified object cannot be directly instantiated on its own since it is incomplete. When a definition is considered abstract like this (explicitly or implicitly), it's usable just as a pure template or abstract object definition that will serve as parent definition for child definitions.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="parent" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The id of another object defined in the current container. A child object definition will use the object class from the parent definition if none is specified, but can also override it.  In the latter case, the child object class must be compatible with the parent, i.e. it must accept the parent's property values. A child object definition will inherit constructor argument values, property values and method overrides from the parent, with the option to add new values. If init method, destroy method and/or static factory method are specified, they will override the corresponding parent settings. The remaining settings will always be taken from the child definition: depends-on, dependency check, singleton, lazy-init.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="depends-on" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">For the relatively infrequent situations where dependencies between objects are less direct (for example, when a static initializer in a class needs to be triggered), the depends-on element may be used to explicitly force one or more objects to be initialized before the object using this element is initialized.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="autowire-candidate" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">True if this object may be used as an autowiring candidate when another object is autowired byType</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="primary" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">True if more than one object of the same type exists in the configuration and the current object needs to be the autowire candidate.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="skip-postprocessors" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Determines whether the object factory will send the created object through its list of IObjectProcessors.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="skip-metadata" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Determines whether the autowire processor will examine the class metadata.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="autowire" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Defines the autowiring strategy to be used for the current object, default is 'no'.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:annotation>
					<xs:documentation>Objects can be autowired by property name, property typeor constructor type.
					Autodetect option choose byType if there is a no arguments constructor, byType otherwise.</xs:documentation>
				</xs:annotation>
				<xs:restriction base="xs:string">
					<xs:enumeration value="no"/>
					<xs:enumeration value="byName"/>
					<xs:enumeration value="byType"/>
					<xs:enumeration value="constructor"/>
					<xs:enumeration value="autodetect"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
        <xs:attribute name="dependency-check" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Defines the dependency check strategy to be used after autowired properties are set for the current object, default is 'none'.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:annotation>
					<xs:documentation>Dependency check can be done just on simple properties (primitives plus Date and Class),
                         Object collaborators, both or no dependency check at all.</xs:documentation>
				</xs:annotation>
				<xs:restriction base="xs:string">
					<xs:enumeration value="none"/>
					<xs:enumeration value="simple"/>
					<xs:enumeration value="objects"/>
					<xs:enumeration value="all"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="templateParamType">
		<xs:annotation>
			<xs:documentation xml:lang="en">Template parameters have a name and a value. Currently only string replacement for parameter values is allowed.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute type="xs:string" name="name" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="en">The name of the placeholder defined in the template.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute type="xs:string" name="value" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="en">The value for the placeholder.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

</xs:schema>
